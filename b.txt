#include "chunk.h"
#include "chunk_manager.h"


Chunk::Chunk(int width, int height, int depth, glm::vec2 index, ChunkManager* manager)
    : width(width), height(height), depth(depth), index_(index), manager(manager), terrainGenerator(width, height, depth, index) {
    std::srand(static_cast<unsigned>(std::time(0)));
    terrainGenerator.generateTerrain(voxels);
}

Chunk::~Chunk() {
    for (Voxel* voxel : voxels) {
        delete voxel;
    }
}

std::tuple<std::vector<float>, std::vector<unsigned int>, std::vector<float>, std::vector<unsigned int>> Chunk::getMesh() const {
    std::vector<float> solidVertices;
    std::vector<unsigned int> solidIndices;
    std::vector<float> waterVertices;
    std::vector<unsigned int> waterIndices;
    glm::vec3 offset(index_.x * width, 0, index_.y * depth);
    unsigned int solidBaseIndex = 0;
    unsigned int waterBaseIndex = 0;

    for (int x = 0; x < width; ++x) {
        for (int y = 0; y < height; ++y) {
            for (int z = 0; z < depth; ++z) {
                glm::vec3 pos(x, y, z);
                Voxel* voxel = getVoxel(pos);
                if (voxel != nullptr) {
                    uint8_t faceFlags = getFaceFlags(pos);
                    if (faceFlags != 0) {  // Only add voxel if it has visible faces
                        if (voxel->getType() == WATER) {
                            addVoxelMesh(voxel, offset, faceFlags, waterVertices, waterIndices, waterBaseIndex);
                        } else {
                            addVoxelMesh(voxel, offset, faceFlags, solidVertices, solidIndices, solidBaseIndex);
                        }
                    }
                }
            }
        }
    }
    return std::make_tuple(solidVertices, solidIndices, waterVertices, waterIndices);
}

void Chunk::addVoxelMesh(Voxel* voxel, const glm::vec3& offset, uint8_t faceFlags,
                         std::vector<float>& vertices, std::vector<unsigned int>& indices,
                         unsigned int& baseIndex) const {
    // Get vertex data
    std::vector<float> voxelVertices = voxel->getVertexData(offset, faceFlags);
    vertices.insert(vertices.end(), voxelVertices.begin(), voxelVertices.end());

    // Get index data
    std::vector<unsigned int> voxelIndices = voxel->getIndexData(baseIndex, faceFlags);
    indices.insert(indices.end(), voxelIndices.begin(), voxelIndices.end());

    baseIndex += popcount(faceFlags) * 4;
}

uint8_t Chunk::getFaceFlags(glm::vec3 pos) const {
    uint8_t flags = 0;
    Voxel* voxel = getVoxel(pos);

    if (voxel == nullptr) {
        return flags;
    }

    if (voxel->getIsXShaped()) {
        flags |= FACE_DIAGONAL_1 | FACE_DIAGONAL_2;
        return flags;
    }

    if (voxel->getType() == WATER) {
        // For water, only check the top face
        Voxel* topNeighbor = getVoxel({pos.x, pos.y + 1, pos.z});
        if (pos.y == height - 1 || topNeighbor == nullptr || topNeighbor->getType() != WATER) {
            flags |= FACE_TOP;
        }
        return flags; // Return early for water voxels
    }

    // For non-water voxels
    auto shouldRenderFace = [this](const glm::vec3& neighborPos) {
        Voxel* neighbor = getVoxel(neighborPos);
        return neighbor == nullptr || neighbor->getType() == WATER || neighbor->getIsXShaped();
    };

    // Check front face
    if (pos.z == depth - 1 || shouldRenderFace({pos.x, pos.y, pos.z + 1})) {
        flags |= FACE_FRONT;
    }

    // Check back face
    if (pos.z == 0 || shouldRenderFace({pos.x, pos.y, pos.z - 1})) {
        flags |= FACE_BACK;
    }

    // Check left face
    if (pos.x == 0 || shouldRenderFace({pos.x - 1, pos.y, pos.z})) {
        flags |= FACE_LEFT;
    }

    // Check right face
    if (pos.x == width - 1 || shouldRenderFace({pos.x + 1, pos.y, pos.z})) {
        flags |= FACE_RIGHT;
    }

    // Check top face
    if (pos.y == height - 1 || shouldRenderFace({pos.x, pos.y + 1, pos.z})) {
        flags |= FACE_TOP;
    }

    // Check bottom face
    if (pos.y == 0 || shouldRenderFace({pos.x, pos.y - 1, pos.z})) {
        flags |= FACE_BOTTOM;
    }

    return flags;
}

Voxel* Chunk::getVoxel(const glm::vec3& pos) const {
    // Check if the position is within this chunk
    if (pos.x >= 0 && pos.x < width && pos.y >= 0 && pos.y < height && pos.z >= 0 && pos.z < depth) {
        int index = static_cast<int>(pos.x + pos.y * width + pos.z * width * height);
        if (index >= 0 && index < voxels.size()) {
            return voxels[index];
        }
        return nullptr;
    }

    // If not in this chunk, determine which neighboring chunk to check
    glm::ivec2 neighborChunkPos = index_;
    glm::vec3 neighborPos = pos;

    if (pos.x < 0) {
        neighborChunkPos.x--;
        neighborPos.x = width - 1;
    } else if (pos.x >= width) {
        neighborChunkPos.x++;
        neighborPos.x = 0;
    }

    if (pos.z < 0) {
        neighborChunkPos.y--;
        neighborPos.z = depth - 1;
    } else if (pos.z >= depth) {
        neighborChunkPos.y++;
        neighborPos.z = 0;
    }

    if (neighborChunkPos.x != index_.x || neighborChunkPos.y != index_.y) {
        std::shared_ptr<Chunk> neighborChunk = manager->getChunk(neighborChunkPos);
        if (neighborChunk) {
            return neighborChunk->getVoxel(neighborPos);
        }
    }

    return nullptr;
}


void Chunk::setVoxel(const glm::vec3& pos, VoxelType type) {
    unsigned int index = coordsToIndex(pos);
    if (index < voxels.size()) {
        delete voxels[index];
        voxels[index] = new Voxel(pos, type);
    }
}

unsigned int Chunk::coordsToIndex(glm::vec3 coords) const {
    return static_cast<unsigned int>(
        coords.x + 
        coords.y * width + 
        coords.z * width * height
    );
}

glm::vec3 Chunk::indexToCoords(int index) const {
    return glm::vec3(
        index % width,
        (index / width) % height,
        index / (width * height)
    );
}

glm::vec2 Chunk::getIndex() const {
    return index_;
}

bool Chunk::operator==(const Chunk& other) const {
    return index_ == other.index_;
}
